---
title: "LBT EWS Analysis"
author: "A.G. Mitchell"
date: "2022-10-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reshape2)
library(ggpol)
library(ggpubr)
library(Rmisc)
library(gghalves)
library(RColorBrewer)
```

# Load data
```{r}
aPath <- '/Users/au706616/Documents/Experiments/PIPTOT/analysis/'
fileName <- 'LBT_compiled-data.csv'
all_dat <- read.csv(file.path(aPath,fileName)) 
```

```{r}
## First, code bisection error
#all_dat$bisect_x_scaled <- all_dat$bisect_x/all_dat$av_rate
# before calculating bisection error check bisect_x and calib_loc_mid make sense
#bisect_check <- aggregate(bisect_x_scaled ~ prolific_id*left_mm*right_mm*calib_loc_midy_x, 
 #                         mean, data = all_dat)
# yep that seems to make sense, now convert and do the same
all_dat$bisect_error <- all_dat$bisect_x - all_dat$calib_loc_midy_x
# then scale the error by coordinate change rate calculated in previous step
all_dat$bisect_error_scaled <- all_dat$bisect_error/all_dat$av_rate
all_dat$bisect_error_scaled <- all_dat$bisect_error_scaled/all_dat$pix_permm

bisect_check <- aggregate(bisect_error_scaled ~ prolific_id*left_mm*right_mm, 
                          mean, data = all_dat)
bisect_check$offset <- (bisect_check$left_mm + bisect_check$right_mm)/2
# yes this step makes sense for most people, plot it just incase

ggplot(bisect_check, aes(group = as.factor(offset), colour = as.factor(offset))) +
  geom_point(aes(bisect_error_scaled, y = 0)) +
  xlim(-75,75) +
  theme_bw() +
  facet_wrap(~prolific_id)


# some more filtering
# remove trials with response > 3000ms
all_dat <- dplyr::filter(all_dat, response_time < 3000)

# identify any participants with too few trials, less than 32 per condition
trials <- aggregate(bisect_error ~ prolific_id*pip*block, length, data = all_dat)
id_x <- trials$prolific_id[trials$bisect_error < 32]

# check all participants have levels of both factors (block and tone)
nblock <- aggregate(bisect_error ~ block*prolific_id, length, data = all_dat)
nblock <- nblock %>% 
  group_by(prolific_id) %>%
  tally()

ntone <- aggregate(bisect_error ~ pip*prolific_id, length, data = all_dat)
ntone <- ntone %>% 
  group_by(prolific_id) %>%
  tally()

# and remove those that don't
id_x <- append(id_x, nblock$prolific_id[nblock$n < 2])
id_x <- append(id_x, ntone$prolific_id[nblock$n < 2])

all_dat <- filter(all_dat, !(prolific_id %in% id_x))
n <- count(all_dat, 'prolific_id')
length(n$prolific_id)

# recode ID
all_dat$prolific_id <- as.factor(all_dat$prolific_id)
all_dat$ID <- as.character(as.numeric(all_dat$prolific_id))
all_dat <- all_dat[order(all_dat$ID), ]
rownames(all_dat) <- NULL
```

# ANALYSIS
End point weightings on both block and tone conditions
```{r}
# recode bisection variables
all_dat$P <- all_dat$bisect_error_scaled
all_dat$L <- all_dat$left_mm
all_dat$R <- all_dat$right_mm
all_dat$ID <- as.factor(all_dat$ID)

# tone and block recoding
all_dat$cond[all_dat$block == 1 & all_dat$pip == 0] <- '1' #block early, tone blank
all_dat$cond[all_dat$block == 1 & all_dat$pip == 1] <- '2' #block early, tone sound
all_dat$cond[all_dat$block == 2 & all_dat$pip == 0] <- '3' #block late, tone blank
all_dat$cond[all_dat$block == 2 & all_dat$pip == 1] <- '4' #block late, tone sound

all_dat$block <- ifelse(all_dat$block == 1, 'EARLY', 'LATE')
all_dat$tone <- ifelse(all_dat$pip == 0, 'BLANK', 'SOUND')

# as factors
all_dat$cond <- as.factor(all_dat$cond)
all_dat$block <- as.factor(all_dat$block)
all_dat$tone <- as.factor(all_dat$tone)

# End point weightings analysis
# TONE
EW_DV <- read.csv(text="ID,tone,block,cond,NUMTRIALS,rsq,k,dPL,dPR")

for(ID in levels(all_dat$ID)){
  for(cond in levels(all_dat$cond)){
    tmp <- all_dat[all_dat$ID == ID & all_dat$cond==cond, 
                   c("bisect_error_scaled","pix_permm","P","L","R")]
    model <- lm(P~L+R, data=tmp)
    #tone = tmp$tone
    #block = tmp$block
    NUMTRIALS <- nrow(tmp)
    rsq <- summary(model)$r.squared
    k <- as.numeric(coefficients(model)[1])
    dPL <- as.numeric(coefficients(model)[2])
    dPR <- as.numeric(coefficients(model)[3])
    
    #add to dataframe
    EW_DV <- rbind(EW_DV, cbind.data.frame(ID,cond,NUMTRIALS,rsq,k,dPL,dPR))
  }
}

#calculate composites
EW_DV$EWB <- EW_DV$dPR-EW_DV$dPL
EW_DV$EWS <- EW_DV$dPR+EW_DV$dPL

EW_DV <- EW_DV %>% 
  rowwise() %>%
  mutate(
    FILT = case_when(rsq < .7 ~ TRUE,
               EWB > .5 ~ TRUE,
               EWS < .5 ~ TRUE
           ))

# flag ids for removal
id_filt <- EW_DV$ID[EW_DV$FILT == TRUE]
id_filt <- id_filt[!is.na(id_filt)]


# calculate final n of participants that can be used (this will be low)
all_dat <- filter(all_dat, !(ID %in% id_filt))
EW_DV <- filter(EW_DV, !(ID %in% id_filt))
final_n <- count(all_dat, 'ID')
length(final_n$ID)
```

# Reliability and distribution checks on data
```{r}
# plot EWS distribution
ggplot(EW_DV, aes(EWB)) +
  geom_density() +
  theme_bw()

ggplot(EW_DV, aes(EWS)) +
  geom_density() +
  theme_bw()

# plot all dPL and dPR to see why EWS is so high
ggplot(EW_DV, aes(dPL, dPR)) +
  geom_point() +
  geom_hline(yintercept = .5) +
  geom_vline(xintercept = .5) +
  ylim(0.3,0.7) + 
  xlim(0.3,0.7) +
  theme_bw()

# test re-test
# clearly define conditions in main data set
EW_DV$block <- ifelse(EW_DV$cond == '1' | EW_DV$cond == '2', 'EARLY', 'LATE')
EW_DV$tone <- ifelse(EW_DV$cond == '1' | EW_DV$cond == '3', 'BLANK', 'SOUND')

block1 <- filter(EW_DV, block == 'EARLY')
names(block1)[8] <- 'EWB_1'
names(block1)[9] <- 'EWS_1'
block2 <- filter(EW_DV, block == 'LATE')
names(block2)[8] <- 'EWB_2'
names(block2)[9] <- 'EWS_2'

DF <- merge(block1, block2, by = 'ID')

# run test re-test

cor(DF$EWS_1, DF$EWS_2)
cor(DF$EWB_1, DF$EWB_2)
```

# First, check for pseudoneglect
```{r}
# EWB
pseudo <- aggregate(EWB ~ ID, mean, data = EW_DV)
#pseudo$xj <- jitter(0, amount = .1)

# run t-test
# EWS - we have pseudoneglect
EWB_test <- t.test(pseudo$EWB, mu = 0, alternative = 'less')
EWB_test

# Now for DBE - first we need to calculate this
# calculate offset of the line - to subtract P from
all_dat$offset <- (all_dat$left_mm + all_dat$right_mm)/2
all_dat$DBE <- all_dat$bisect_error_scaled - all_dat$offset

DBE_line <- aggregate(DBE ~ ID*cond*block*tone, mean, data = all_dat)
# average across all and get pseudoneglect
DBE <- aggregate(DBE ~ ID, mean, data = DBE_line)

# DBE test
DBE_test <- t.test(DBE$DBE, mu = 0, alternative = 'less')
DBE_test

# add DBE to pseudo then plot
pseudo <- merge(pseudo, DBE, by = 'ID')
# for compete picture, add EWS
EWS <- aggregate(EWS ~ ID, mean, data = EW_DV)
pseudo <- merge(pseudo, EWS, by = 'ID')
# melt
pseudo <- melt(pseudo, value.name = 'BIAS')
# add h line to the data
data_hline <- data.frame(variable = unique(pseudo$variable),  # Create data for lines
                         hline = c(0, 0, 1))


# first, plot
av_plot <- ggplot(pseudo, aes(x = 1, y = BIAS, group = variable)) +
  geom_boxjitter(width = .2,errorbar.length = .2, jitter.shape = 21, 
                 jitter.size = 1.5, outlier.shape = NA, errorbar.draw = TRUE, 
                 lwd = 0.7, notch = TRUE) +
  xlim(.8,1.2) +
  facet_wrap(~variable, scales = "free") +
  theme_classic()

av_plot +   geom_hline(data = data_hline,
             aes(yintercept = hline))

# summarise pseudo
pseudo_sum <- summarySEwithin(data = pseudo, measurevar = 'BIAS', withinvars = 'variable')
```

# Analysis across blocks
```{r}
# colour
blues <- brewer.pal(9, "Blues")
# isolate silent trials only
tonic <- filter(EW_DV, tone == 'BLANK')
# recode block
tonic$block <- ifelse(tonic$block == 'EARLY', 1, 2)
tonic$xj <- jitter(tonic$block, .2)
sum_tonic <- summarySEwithin(data = tonic, measurevar = 'EWS', withinvars = 'block')

# first plot EWS by block
ggplot(tonic, aes(group = ID, colour = as.factor(block), fill = as.factor(block))) +
  # all data
  geom_half_violin(aes(as.factor(block), EWS, group = block),
                   position = position_nudge(x = -.05), side = "l", 
                   alpha = .4) +
  geom_point(aes(xj, EWS), position = position_nudge(.05), shape = 21, alpha = .7) +
  # summar data
  geom_point(data = sum_tonic, aes(block, EWS), 
             position = position_nudge(-.05), colour = 'grey20', size = 0.5) +
  geom_pointrange(data = sum_tonic, aes(block, y = EWS, 
                                        ymin = EWS-ci, ymax = EWS+ci), 
                position = position_nudge(-.05), size = 0.75, colour = 'grey20') +
  # connect the two lines
  geom_line(data = sum_tonic, 
            aes(x = block, y = EWS), 
            size = 0.75, position = position_nudge(-.05), colour = 'grey20') +
  scale_colour_manual(values = c(blues[4], blues[7])) +
  scale_fill_manual(values = c(blues[4], blues[7])) +
  scale_x_discrete(breaks = c(1,2), labels = c('Early', 'Late')) +
  labs(title = 'Time On Task', x = 'Block') +
  theme_classic() +
  theme(legend.position = 'none')

# is this difference at all significant??
# cast tonic
tonic_wide <- dcast(tonic, ID ~ block, value.var = "EWS")
# difference between early and late
tonic_wide$DIFF <- tonic_wide$EARLY - tonic_wide$LATE
block_test <- t.test(tonic_wide$DIFF, mu = 0, alternative = 'less')
block_test
```
# Analysis across tones
```{r}
# first, average silent and toned trials by block
phasic_wide <- dcast(EW_DV, ID ~ block*tone, value.var = 'EWS')
phasic_wide$BLANK <- rowMeans(phasic_wide[, c(2,4)])
phasic_wide$SOUND <- rowMeans(phasic_wide[, c(3,5)])

# first plot EWS by tone
# melt
phasic <- phasic_wide[, c(1,6,7)]
phasic <- melt(phasic, value.name = 'EWS', variable.name = 'tone')
# summary data
sum_phasic <- summarySEwithin(data = phasic, measurevar = 'EWS', withinvars = 'tone')

ggplot(phasic, aes(tone, EWS, group = ID)) +
  geom_hline(aes(yintercept = 1)) +
  geom_point(position = position_dodge(.2), shape = 21) +
  geom_point(data = sum_phasic, aes(tone, EWS), 
             position = position_nudge(-.15), size = 3) +
  theme_classic()

# is this difference at all significant??
# difference between early and late
phasic_wide$DIFF <- phasic_wide$SOUND - phasic_wide$BLANK
tone_test <- t.test(phasic_wide$DIFF, mu = 0, alternative = 'greater')
tone_test
```


```{r}
```

# Further checks
# Run the same analyses as above, but this time on EWB
```{r}
# across blocks
# isolate silent trials only
sum_tonic_bias <- summarySEwithin(data = tonic, measurevar = 'EWB', withinvars = 'block')

# plot EWB by block - looks like the reverse effect is found here
ggplot(tonic, aes(block, EWB, group = ID)) +
  geom_hline(aes(yintercept = 0)) +
  geom_point(position = position_dodge(.2), shape = 21) +
  geom_point(data = sum_tonic_bias, aes(block, EWB), 
             position = position_nudge(-.15), size = 3) +
  theme_classic()

# is this difference at all significant??
# cast tonic
tonic_bias <- dcast(tonic, ID ~ block, value.var = "EWB")
# difference between early and late
tonic_bias$DIFF <- tonic_bias$EARLY - tonic_bias$LATE
block_bias_test <- t.test(tonic_bias$DIFF, mu = 0, alternative = 'greater')
block_bias_test

# across tone
# first, average silent and toned trials by block
phasic_bias_wide <- dcast(EW_DV, ID ~ block*tone, value.var = 'EWB')
phasic_bias_wide$BLANK <- rowMeans(phasic_bias_wide[, c(2,4)])
phasic_bias_wide$SOUND <- rowMeans(phasic_bias_wide[, c(3,5)])

# first plot EWS by tone
# melt
phasic_bias <- phasic_bias_wide[, c(1,6,7)]
phasic_bias <- melt(phasic_bias, value.name = 'EWB', variable.name = 'tone')
# summary data
sum_phasic_bias <- summarySEwithin(data = phasic_bias, measurevar = 'EWB', withinvars = 'tone')

ggplot(phasic_bias, aes(tone, EWB, group = ID)) +
  geom_hline(aes(yintercept = 0)) +
  geom_point(position = position_dodge(.2), shape = 21) +
  geom_point(data = sum_phasic_bias, aes(tone, EWB), 
             position = position_nudge(-.15), size = 3) +
  theme_classic()

# is this difference at all significant??
# difference between early and late
phasic_bias_wide$DIFF <- phasic_bias_wide$SOUND - phasic_bias_wide$BLANK
tone_bias_test <- t.test(phasic_bias_wide$DIFF, mu = 0, alternative = 'less')
tone_bias_test
```
---
title: "Beyond Bias - Data Compile code"
author: "A.G. Mitchell"
date: "2022-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reshape2)
```

# Setting paths for raw data and analysis
```{r}
dPath <- '/Users/au706616/Documents/Experiments/PIPTOT/LBTraw'
aPath <- '/Users/au706616/Documents/Experiments/PIPTOT/analysis'

datname <- 'LBTraw_120.csv'
qualname <- 'QUALraw.csv'

# load raw and qual data
bisectData <- read.csv(file.path(dPath,datname)) 
qualData <- read.csv(file.path(dPath,qualname)) 
```

# Quick data quality checks - main data
```{r}
# first get an idea of all participants (prolific IDs)
nres <- aggregate(acc~prolific_id, length, data=bisectData)
length(nres$prolific_id)

# n particiants removed who failed audio check/too few trials
nAudio <- dplyr::filter(nres, acc < 200)
id_x <- nAudio$prolific_id #identifying participants to be removed

# count void trials - identify excessive
void <- dplyr::filter(bisectData, void_trial == 1)
nVoid <- aggregate(void_trial~prolific_id, length, data=void)

compareVoid <- merge(nVoid, nres, by = 'prolific_id')

# final audio check, correct?
finalAudio <- bisectData[bisectData$response_audio_kbd_final == 7 ,]
finalAudio <- finalAudio[, c(225,237)]
length(finalAudio$queryParams_PROLIFIC_PID)

# filter trials so audio = passed, this removes audio step and filters participants who failed
bisectData <- dplyr::filter(bisectData, audio_passed == 1)
# then remove void trials
bisectData <- dplyr::filter(bisectData, void_trial == 0 & practice == 0)
# number of trials for each participant with void and practice removed
ntrials <- aggregate(bisect_x~prolific_id, length, data=bisectData)
# order by prolific id for easy identification
ntrials <- ntrials[order(ntrials$prolific_id) ,]
# identify any participants with too few trials (again)
## ADD THE ABOVE ID_X TO THIS ID_X - AND FIND OUT HOW
id_x <- append(id_x, ntrials$prolific_id[ntrials$bisect_x < 192]) #fewer than total number of trials
id_x <- append(id_x, ntrials$prolific_id[ntrials$bisect_x > 192]) #more than

# remove participants with too few trials from full data set
bisectData <- filter(bisectData, !(prolific_id %in% id_x))
# n remaining participants
nvalid <- aggregate(bisect_x~prolific_id, length, data=bisectData)
length(nvalid$prolific_id)
# narrow down data-frame to relevant columns only - putting important first
all_dat <- bisectData[, c(224,11,12,289,211,212,274,275,214,36,37,46,89,164,165,206,207,
                          208,216:218,222,228,229,237,251,352,356,319,321,386,388)]
# data for calibration check, seperate from main df
calib_dat <- bisectData[, c(224,17:34,172:189,208)]
```

# Organise qualitative data
CHECK THIS STEP WITH FINAL DATASET
```{r}
## Qualitative data
# Load and merge with qualitative data
## Qualitative data
qualData <- read.csv(file.path(dPath,qualname)) 

# first, some renaming and reorganising of the qual data
names(qual10Data)[1] <- 'consent'
names(qual10Data)[2] <- 'prolific_id'
names(qual10Data)[3] <- 'gender'
names(qual10Data)[4] <- 'age'

# split off EHI
EHI <- qualData[, c(2,6:15)]
qualData <- qualData[, c(2,1,3,4,16)]

# merge with bisection data using jatos IDs to obtain prolific id, to merge data-frames
dat10 <- merge(qual10Data, dat10, by = 'jatosStudyResultId')
calib10 <- merge(qual10Data, calib10, by = 'jatosStudyResultId')
# remove unecessary columns from calib10 - to match other calibration
calib10 <- calib10[, -c(3,4,5)]
```

# Quick data quality checks - first 10 participants
This is slightly different than above because PIDs were not recorded for the first 10
participants. Have manually matched all JATOS IDs with PIDs

Run the same steps as above on these data
```{r}
# do the same as above for the first 10 participants (collected seperately)
# then combine their data
dat10name <- 'LBTraw_first10.csv'
qual10name <- 'QUALraw_first10.csv'

# first only load the raw data because demographic is a little useless at this stage
bisect10Data <- read.csv(file.path(dPath,dat10name)) 

# same filtering as above
# first get an idea of all participants (prolific IDs)
nres10 <- aggregate(acc~jatosStudyResultId, length, data=bisect10Data)
length(nres10$jatosStudyResultId)

# n particiants removed who failed audio check/too few trials
nAudio10 <- dplyr::filter(nres10, acc < 200)
id_x10 <- nAudio10$jatosStudyResultId #identifying participants to be removed
# count void trials
void10 <- dplyr::filter(bisect10Data, void_trial == 1)
nVoid10 <- aggregate(void_trial~jatosStudyResultId, length, data=void10)
# remove participants with excessive void trials
## how to do this??

# final audio check, correct?
finalAudio10 <- bisect10Data[bisect10Data$response_audio_kbd_final == 7 ,]
finalAudio10 <- finalAudio10[, c(224,198)]

# filter trials so audio = passed, this removes audio step and filters participants who failed
bisect10Data <- dplyr::filter(bisect10Data, audio_passed == 1)
# then remove void trials
bisect10Data <- dplyr::filter(bisect10Data, void_trial == 0 & practice == 0)
# number of trials for each participant with void and practice removed
ntrials10 <- aggregate(bisect_x~jatosStudyResultId, length, data=bisect10Data)

# remove 1 participant with too few trials
bisect10Data <- filter(bisect10Data, !(jatosStudyResultId %in% id_x10))

# narrow down data-frame for correct columns only
dat10 <- bisect10Data[, c(11,12,271,201,202,256,257,204,36,37,45,81,154,155,196,197,
                          198,206:208,212,215,218,219,224,237,326,330,294,296,359,361)]
calib10 <- bisect10Data[, c(17:34,162:179,198)]
```

```{r}
## Qualitative data
qual10Data <- read.csv(file.path(dPath,qual10name)) 
# flag PIDs with no code & no data
nPID <- c('611e1eee7989eadcee23045c', '6025df3ed83eed206142329a', '6130d846086f43ecd225d128')
# qualitative data
# first, some renaming and reorganising of the qual data
names(qual10Data)[1] <- 'consent'
names(qual10Data)[2] <- 'prolific_id'
names(qual10Data)[3] <- 'gender'
names(qual10Data)[4] <- 'age'
# remove no code PIDs from quantitative
qual10Data <- filter(qual10Data, !(prolific_id %in% nPID))

# split off EHI
EHI10 <- qual10Data[, c(2,6:15)]
qual10Data <- qual10Data[, c(2,1,3,4,16)]

# merge with bisection data using jatos IDs to obtain prolific id, to merge data-frames
dat10 <- merge(qual10Data, dat10, by = 'jatosStudyResultId')
calib10 <- merge(qual10Data, calib10, by = 'jatosStudyResultId')
# remove unecessary columns from calib10 - to match other calibration
calib10 <- calib10[, -c(3,4,5)]
```

# Merge to get final dataset and final numbers!
```{r}
# Merge the smaller initial data set with the main data set to get final numbers
```

# Screen calibration
Check and remove participants where calib and dot locations do not match 
Criteria:

```{r}
# Calibration check
# First bind two calibration files
calib_dat <- rbind(calib_dat, calib10)
# check numbers - do they match above
ncalib <- count(calib_dat, 'prolific_id')
length(ncalib$prolific_id) # yes, there are 113 prolific ids here

# then aggregate calibration values by id - include na values in this step
calibDat <- aggregate(.~prolific_id, median, data = calib_dat, na.action = NULL)
# remove participants with all NAs (aka did not complete calib task)
n_rows <- which(rowSums(is.na(calibDat))>10) 
n_rows #print out - to identify how many
calibDat <- calibDat[-n_rows ,]

# remove JATOS is
calibDat <- calibDat[, -c(38)]
# renaming so convention works for data wrangling & plotting
calibDat <- dplyr::rename(
  calibDat,
  'calib_loc_left192x_x' = 'calib_loc_left192x',
  'calib_loc_left320x_x' = 'calib_loc_left320x',
  'calib_loc_left480x_x' = 'calib_loc_left480x',
  'calib_loc_lowery_y' = 'calib_loc_lowery',
  'calib_loc_midy_y' = 'calib_loc_midy',
  'calib_loc_right192x_x' = 'calib_loc_right192x',
  'calib_loc_right320x_x' = 'calib_loc_right320x',
  'calib_loc_right480x_x' = 'calib_loc_right480x',
  'dot_loc_left192x_x' = 'dot_loc_left192x',
  'dot_loc_left320x_x' = 'dot_loc_left320x',
  'dot_loc_left480x_x' = 'dot_loc_left480x',
  'dot_loc_lowery_y' = 'dot_loc_lowery',
  'dot_loc_midy_y' = 'dot_loc_midy',
  'dot_loc_right192x_x' = 'dot_loc_right192x',
  'dot_loc_right320x_x' = 'dot_loc_right320x',
  'dot_loc_right480x_x' = 'dot_loc_right480x'
   )
              
calib_points <- reshape2::melt(calibDat, value.name = 'RESP') #reshaping dataframe
# extracting important variables
calib_points$COND <- factor(substr(calib_points$variable, 1, 3))
# dot axes - x and y
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}
calib_points$AXIS <- substrRight(as.character(calib_points$variable), 1)
# then identify relevant dot locations
# dot locations
for (var in 1:length(calib_points$variable)){
  if (isTRUE(calib_points$COND[var] == 'cal')){
    calib_points$LOC[var] <- substr(calib_points$variable[var], 11, 
                                nchar(as.character(calib_points$variable[var]))-2)
  }
  else {
    calib_points$LOC[var] <- substr(calib_points$variable[var], 9, 
                                nchar(as.character(calib_points$variable[var]))-2)
  }
}
# order by prolific id
calib_points <- calib_points[order(calib_points$prolific_id) ,]
# code a seperate ID variable
calib_points$prolific_id <- as.factor(calib_points$prolific_id)
calib_points$ID <- as.character(as.numeric(calib_points$prolific_id))
calib_points$ID <- as.factor(calib_points$ID)

# plot x axis
x_plot <- ggplot(
  calib_points %>% 
    filter(AXIS == 'x'), 
  aes(RESP, 0, colour = LOC, shape = COND)) +
  geom_point() +
  scale_shape_manual(values = c(3, 1)) +
  facet_wrap(~ID)
# plot y axis
y_plot <- ggplot(
  calib_points %>% 
    filter(AXIS == 'y'), 
  aes(0, RESP, colour = LOC, shape = COND)) +
  geom_point() +
  scale_shape_manual(values = c(3, 1)) +
  facet_wrap(~ID)

# Regressing calibration values
# get data for linear regression
# group by COND
CLK <- dplyr::filter(calib_points, COND == 'cal')
DOT <- dplyr::filter(calib_points, COND == 'dot')
names(CLK)[3] <- 'LOC_CLK'
names(DOT)[3] <- 'LOC_DOT'

CALFIT <- merge(CLK, DOT, by = c('ID','LOC','AXIS','prolific_id'))
CALFIT <- CALFIT[, -c(5,7,8,10)]

# THEN fit with linear regression below 
# identify Rsq for each participant and see if fit >.9

calibR <- read.csv(text = c('prolific_id,NUMTRIALS,RSQ'))

for(prolific_id in levels(CALFIT$prolific_id)){
    tmp <- CALFIT[CALFIT$prolific_id == prolific_id, c("LOC_CLK","LOC_DOT")]
    model <- lm(LOC_CLK~LOC_DOT, data=tmp, na.action = na.exclude)
    NUMTRIALS <- nrow(tmp)
    RSQ <- summary(model)$r.squared
    #add to dataframe
    calibR <- rbind(calibR, cbind.data.frame(prolific_id,NUMTRIALS,RSQ))
}

# identify and remove participants with r2 < .9
## participants whose cal_fit < .9
calibR$FILTER <- calibR$RSQ < .90
# adding to ID_X data-frame for later removal
id_x <- c(id_x, as.character(calibR[calibR$FILTER == TRUE, "prolific_id"]))
length(id_x)

# remove participants who failed calib check from current data-set
all_dat <- filter(all_dat, !(prolific_id %in% id_x))

# get final numbers
n <- count(all_dat, 'prolific_id')
length(n$prolific_id)
```

# Saving!
Save all_dat and calib_dat dataframes
```{r}
```

Move the below section to a new code
# Data wrangling!

```{r}
# check bisection of all lines - first calculate bisection error
bisectData$bisect_error <- bisectData$bisect_x - bisectData$calib_loc_midy_x
# convert error into mm
bisectData$bisect_error <- bisectData$bisect_error/bisectData$pix_permm

# mean bisect error across lines & sounds
bisectError_sound <- aggregate(bisect_error ~ sound*right_mm*left_mm*jatosStudyResultId, 
                         mean, data = bisectData)
# mean bisect error across lines & blocks
bisectData$block_count <- ifelse(is.na(bisectData$count_block_2_sequence), 1, 2) #identifying block
bisectError_time <- aggregate(bisect_error ~ block_count*right_mm*left_mm*jatosStudyResultId, 
                         mean, data = bisectData)

# time of breaks
bisectData$break_length <- bisectData$time_break_time_stamp - bisectData$time_block_one_end 
bisectData$break_length <- bisectData$break_length/100 #in seconds
```
